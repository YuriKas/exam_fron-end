## JavaScript
* funcion y expresión

La función se declara y realza determinadas funciones.
Function a(){
}
Expresion permite declararle un contenido.
Var despedido  = “bye bye”;

* diferencia entre == y ===
 === Operadores de comparación estricta.
1 === "1" // false
1 !== "1"  // true
null === undefined // false


== operadores de comparación relajada.
1 == "1" // true
1 != "1" // false
null == undefined // true

* arrow function

var str = func => ({id: '8'})

* normal function

function str (arg1, arg2) {   console.log ('Renu'); }

* tipos de datos
Int,String, Array, etc

* hoisting
In JavaScript, a variable can be declared after it has been used.

x = 5; // Assign 5 to x

elem = document.getElementById("demo"); // Find an element 
elem.innerHTML = x;                     // Display x in the element

var x; // Declare x

* Apply y bind
El método call invoca a la función con el valor de this que se especifique como primer argumento:

 3
4
5
6
7
8
9
10
11
12
13
 
var obj = {
  valor: 10
};
 
multiplicar.call(obj, 2); // 20
 
var obj2 = {
  valor: 8
};
 
multiplicar.call(obj, 4); // 32

El método apply es prácticamente igual que call, también invoca a la función, excepto que los argumentos adicionales se deben pasar como un arreglo:

var obj = {
  valor: 10
};
 
multiplicar.apply(obj, [2]); // 20
 
var obj2 = {
  valor: 8
};
 
multiplicar.apply(obj, [4]); // 32


El método bind es diferente de los dos anteriores porque no invoca directamente a la función sino que devuelve una copia que hace referencia al objeto this que se especifique, junto con los argumentos proporcionados:

var obj = {
  valor: 10
};
 
var multiplicarPor5 = multiplicar.bind(obj, 5);
multiplicarPor5(); // 50



## Angular - Angular.js y Angular 6
### Angular JS 1.xxx
* como es un controlador - controller
Los controladores en AngularJS son objetos que permiten desarrollar la lógica de la aplicación, enlaza el ámbito, $scope, con la vista y permite tener un control total de los datos. Explicándolo de otra manera, es el encargado de gestionar los eventos.
Los controladores se enlazan a la vista mediante la directiva ng-controller, aunque existe una excepción que lo veremos cuando toquemos el tema de rutas, ahora veamos como declarar un controlador.

var app = angular.module('MyApp', []);
app.controller('mainController', function($scope){
   //contenido
});

* como es un servicio
services are substitutable objects that are wired together using dependency injection (DI). You can use services to organize and share code across your app.

AngularJS services are:

Lazily instantiated – AngularJS only instantiates a service when an application component depends on it.
Singletons – Each component dependent on a service gets a reference to the single instance generated by the service factory.
AngularJS offers several useful services (like $http), but for most applications you'll also want to create your own.

var myModule = angular.module('myModule', []);
myModule.factory('serviceId', function() {
  var shinyNewServiceInstance;
  // factory function body that constructs shinyNewServiceInstance
  return shinyNewServiceInstance;
});



* como es una directiva

las directivas vienen a ser la forma en la que extendemos nuestro HTML, permiten agregar desde pequeños trozos de código hasta una funcionalidad completa.

Directivas ANtivas declaradas en camelCase:
ngApp, ngController, ngModel,ngClick, ngRepeat, ngChange, ngShow.

Directivas creadas:
var app = angular.module('MiModulo',[]);
app.controller('MiControlador', function($scope){
  $scope.cliente = {
    nombre: 'Jhon',
    direccion: 'Av. Jose pardo 481'
  };
});

//Aquí creamos la directiva
app.directive('miCliente', function() {
  return {
    template: 'Nombre: {{cliente.nombre}} Dirección: {{cliente.direccion}}'
  };
});

<body>
   <div ng-controller="MiControlador">
      <div mi-cliente></div>
   </div>
</body>

________

 app.controller('MiControlador', function($scope) {
    $scope.cliente1 = {nombre: 'Percy', direccion: 'Calle Los Manzanos'};
    $scope.cliente2 = {nombre: 'Gerardo', direccion: 'Calle Dueñas'};
  })
  app.directive('miCliente', function() {
    return {
      restrict: 'AE',
      scope: {
        clienteDinamico: '=cliente'
      },
      templateUrl: 'cliente.html'
    }
  });
  
  cliente.html
  
  <div class="page">
      <h1>{{clienteDinamico.nombre}} vive en {{clienteDinamico.direccion}}</h1>
   </div>
   
   <body>
   <div ng-controller="MiControlador">
      <mi-cliente cliente="cliente1" ></mi-cliente>
      <mi-cliente cliente="cliente2" ></mi-cliente>
   </div>
</body>
   
   
* como funciona el ruteo
  * it reads the browser URL the user wants to navigate to
  * it applies a URL redirect (if one is defined)
  * it figures out which router state corresponds to the URL
  * it runs the guards that are defined in the router state
  * it resolves the required data for the router state
  * it activates the Angular components to display the page
  * it manages navigation and repeats the steps above when a new page is requested.
  
* ciclo de vida del ruteo
This routing module acts based on the url. When a user requests a specific url, the routing engine captures that url and renders the view based on the defined routing rules.

// Creación del módulo
var angularRoutingApp = angular.module('angularRoutingApp', ['ngRoute']);

// Configuración de las rutas
angularRoutingApp.config(function($routeProvider) {

	$routeProvider
		.when('/', {
			templateUrl	: 'pages/home.html',
			controller 	: 'mainController'
		})
		.when('/acerca', {
			templateUrl : 'pages/acerca.html',
			controller 	: 'aboutController'
		})
		.when('/contacto', {
			templateUrl : 'pages/contacto.html',
			controller 	: 'contactController'
		})
		.otherwise({
			redirectTo: '/'
		});
});

angularRoutingApp.controller('mainController', function($scope) {
	$scope.message = 'Hola, Mundo!';
});

angularRoutingApp.controller('aboutController', function($scope) {
	$scope.message = 'Esta es la página "Acerca de"';
});

angularRoutingApp.controller('contactController', function($scope) {
	$scope.message = 'Esta es la página de "Contacto", aquí podemos poner un formulario';
});

<!-- index.html -->
<html ng-app='angularRoutingApp'>
<head>
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" />
</head>
<body ng-controller='mainController'>
  <header>
    <h1>Angular Routing</h1>
      <nav> 
        <ul> 
          <li><a href="#">Inicio</a></li>
          <li><a href="#acerca">Acerca de</a></li>
          <li><a href="#contacto">Contacto</a></li> 		</ul> 
      </nav>
    </header>
    <div id="main">
      <!-- Aquí inyectamos las vistas -->
      <div ng-view></div> 
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.2.7/angular.min.js"></script> 
    <script src="//cdnjs.cloudflare.com/ajax/libs/angular.js/1.2.3/angular-route.js"></script>
    <script src="main.js"></script>
  </body>
  </html>

* como funcionan los scopes
The scope is the binding part between the HTML (view) and the JavaScript (controller).

The scope is an object with the available properties and methods.

The scope is available for both the view and the controller.

<div ng-app="myApp" ng-controller="myCtrl">

<h1>{{carname}}</h1>

</div>

<script>
var app = angular.module('myApp', []);

app.controller('myCtrl', function($scope) {
    $scope.carname = "Volvo";
});
</script>

* tipos de scopes
$rootScope & $scope

$scope is glue between a controller and view (HTML). It transfers data from the controller to view and vice-versa.

$rootScope
An AngularJS application has a single $rootScope. All the other $scope objects are child objects.

The properties and methods attached to $rootScope will be available to all the controllers.

<!DOCTYPE html>
<html>
<head>
    <title>AngualrJS Controller</title>
    <script src="~/Scripts/angular.js"></script>
</head>
<body ng-app="myNgApp">
    <div ng-controller="parentController">
        Controller Name: {{controllerName}} <br />
        Message: {{message}} <br />
        <div style="margin:10px 0 10px 20px;" ng-controller="childController">
            Controller Name: {{controllerName}} <br />
            Message: {{message}} <br />
        </div>
    </div>
    <div  ng-controller="siblingController">
        Controller Name: {{controllerName}} <br />
        Message: {{message}} <br />
    </div>
    <script>
        var ngApp = angular.module('myNgApp', []);

        ngApp.controller('parentController', function ($scope, $rootScope) {
            $scope.controllerName = "parentController";
            $rootScope.message = "Hello World!";
        });

        ngApp.controller('childController', function ($scope) {
            $scope.controllerName = "childController";
        });

        ngApp.controller('siblingController', function ($scope) {

        });
    </script>
</body>
</html>

* isolated scope & inherited scope

Shared and Inherited Scope
Shared scope and inherited scope are relatively easier to understand. In a shared scope, directives share the scope with the enclosed controller.
Let us assume that we have a controller, as shown in the listing below:
 
MyApp.controller('StudentController', ['$scope', function ($scope) {
    console.log($scope);
    $scope.student = {
        name: "dj",
        age: 32,
        subject: [
            "math",

            "geography"

        ]

    }
 
    $scope.setGrade = function (student) {
        student.grade = "A+"
    }
 
}]);
 
Next, let’s go ahead and create a custom directive:
 
MyApp.directive('studentDirective', function () {
    return {
        template: "
{{student.name}} is {{student.age}} years old !!
",
        replace: true,
        restrict: 'E',
        controller: function ($scope) {
            console.log($scope);
        }
    }
});
 
Here, we can use the studentdirective on the view:
 
<div ng-controller="StudentController">
            <student-directive> student-directive>
  div>
  
 
 Isolated Scope
In Isolated scope, the directive does not share a scope with the controller; both directive and controller have their own scope. Data, however, can be passed to the directive scope in three possible ways.
1.       Data can be passed as a string using the @ string literal

2.       Data can be passed as an object using the = string literal

3.       Data can be passed as a function the & string literal

 
 
 
An isolated scope is very important because it allows us to pass different data to the controller. To understand it better, let’s assume that we have a controller as listed below:
 
MyApp.controller("ProductController", function ($scope) {
    $scope.product1 = {
        name: 'Phone',
        price: '100',
        stock: true
    };
    $scope.product2 = {
        name: 'TV',
        price: '1000',
        stock: false
    };
    $scope.product3 = {
        name: 'Laptop',
        price: '800',
        stock: false
    };
 
    $scope.ShowData = function () {
        alert("Display Data");
    }
 
});


* define un modulo

Los módulos vienen a ser contenedores de diferentes partes de nuestra aplicación. Podemos definir la cantidad de módulos que nos sean necesarios para desacoplar totalmente el código, sea por características, por funcionalidad, por componente reusable.

var app = angular.module('Nombre_del_modulo', ['ngRoute']);

* como se hace un componente

In AngularJS, a Component is a special kind of directive that uses a simpler configuration which is suitable for a component-based application structure.

angular
  .module("appProbandoComponent", [])
  .component("probandoComponent", {
    template: [
      '<div class="miclase">',
      '<span>Esto es algo de HTML en el componente</span> ',
      '<b>Angular Rules!</b>',
      '</div>'
    ].join('')
  });
  Lo importante que tienes que observar del código anterior:

  * Usamos el método component() para definir el componente. Ese método recibe el nombre del componente y el objeto que lo define.
  * El nombre del componente que pasamos a la función component debe estar escrito en "camel case", si es que está compuesto por varias palabras. Pero luego veremos que en el HTML nos referimos al componente separando las palabras por guiones.
  * En el objeto enviado al componente le indicamos el atributo "template" que tiene el HTML del marcado del componente. Luego veremos que existe un atributo llamado "templateUrl" que es más interesante por contener una ruta para un archivo HTML donde colocaremos el marcado de manera separada.
Y ahora veamos cómo se usaría:

<probando-component></probando-component>

* build and publish and application
* isolated scope & inherited scope
isolate: 

scope: {
  myProperty: '='
}

inherited:

scope: true

No scope:

Scrope: false

* funcion anonima
como cualquier función creada con una declaración de función. 

var area = function(ancho, alto) {
    return ancho * alto;
};
 
var medida = area(3, 4);


* función síncrono y asíncrono
Síncrono: es frecuente emplear 'bloqueante' y 'síncrono' como sinónimos, dando a entender que toda la operación de entrada/salida se ejecuta de forma secuencial y, por tanto, debemos esperar a que se complete para procesar el resultado.
Asíncrono: la finalización de la operación I/O se señaliza más tarde, mediante un mecanismo específico como por ejemplo un callback, una promesa o un evento (se explicarán después), lo que hace posible que la respuesta sea procesada en diferido. Como se puede adivinar, su comportamiento es no bloqueante ya que la llamda I/O devuelve inmediatamente.(Espera a que se resuelva para mandar la respuesta)

* variables var/let/const
Var
//ES5
(function() {
	console.log(x); // x no está definida aún.
    if(true) {
    	var x = "hola mundo";
    }
    console.log(x); 
    // Imprime "hola mundo", porque "var" hace que sea global
    // a la función;
})();
__________________-

let y const
//ES6
(function() {
	if(true) {
    	let x = "hola mundo";
    }
    console.log(x); 
    //Da error, porque "x" ha sido definida dentro del "if"
})();
(function() {
	const PI = 3.15;
    PI = 3.14159;
    // ERROR de nuevo, porque es sólo-lectura
})();
* Versiones de Angular
Angular 1,2,4,5,6


#### Angular 6
* como es un servicio
Service is a broad category encompassing any value, function, or feature that an app needs. A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well. 

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class HeroService {

  constructor() { }

}


* como es una directiva
native directives:
*ngIf, *ngFor, *ngSwitch,

import { Directive, ElementRef, HostListener } from '@angular/core';
 
@Directive({
    selector: '[appMyFirstDirective]'
})
export class MyFirstDirectiveDirective {
 
    constructor(private element: ElementRef){}
 
    @HostListener('mouseenter')
    publiconMouseEnter(){
 
    }
 
    @HostListener('mouseleave')
    publiconMouseLeave(){
   
    }
}

* como funciona el ruteo
  * Enter a URL in the address bar and the browser navigates to a corresponding page.
  * Click links on the page and the browser navigates to a new page.
  * Click the browser's back and forward buttons and the browser navigates backward and forward through the history of pages you've seen.
it reads the browser URL the user wants to navigate to
it applies a URL redirect (if one is defined)
it figures out which router state corresponds to the URL
it runs the guards that are defined in the router state
it resolves the required data for the router state
it activates the Angular components to display the page
it manages navigation and repeats the steps above when a new page is requested.

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AppComponent } from './app.component';

const routes: Routes = [
  {
    path: '',
    redirectTo: 'todos',
    pathMatch: 'full'
  },
  {
    path: 'todos',
    component: AppComponent
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: []
})
export class AppRoutingModule {
}

* como funcionan los scopes

* tipos de scopes

* isolated scope & inherited scope

* como seria una directiva
una directiva se define como una clase que utiliza el decorador @Directive.

Las directivas estructurales comienzan por asterisco y sirven para alterar el DOM.

*ngIf: si la condición se cumple, su elemento se inserta en el DOM, en caso contrario, se elimina del DOM. (equivale al ng-if de AngularJS)
*ngFor: repite su elemento en el DOM una vez por cada item que hay en el iterador que se le pasa, siguiendo una sintaxis de ES6. (equivale al ng-for de AngularJS)
A nivel de código, los utilizaríamos así:

<div *ngFor="let todo of todos"></div>
<todo-detail *ngIf="selectedTodo"></todo-detail>

Las directivas Atributo alteran la apariencia o comportamiento de un elemento del DOM
ngModel
  <input [(ngModel)]="todo.subject" >
ngClass
  <div [ngClass]="setTodoClasses()">Este ToDo es importante y está pendiente</div>
ngStyle
  <div [ngStyle]="setStyles()"></div>
 
 ___
 
 import { Directive, ElementRef } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
    constructor(el: ElementRef) {
       el.nativeElement.style.backgroundColor = 'yellow';
    }
}

<p appHighlight>Highlight me!</p>

 
* define tu modulo
Organizar las partes de nuestra aplicación. Ordenando la misma en bloques. Permitiendo extender nuestra aplicación con funcionalidades de librerías externas. Permite a angular saber las importaciones / exportaciones necesarias para que cierto componente funcione.

es una clase con un decorador llamado @NgModule.
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MicomponenteComponent } from './micomponente/micomponente.component';

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [
    MiComponenteComponent
  ]
})
export class NombreModuloModule { }

<app-mi-componente></app-mi-componente>


* como se hace un componente
import { Component } from '@angular/core';
@Component({
  moduleId: module.id,
  selector: 'test-angular2-app',
  templateUrl: 'test-angular2.component.html',
  styleUrls: ['test-angular2.component.css']
})

moduleId: esta propiedad puede parecer un poco extraña, porque siempre se le asigna el mismo valor en todos los componentes. Realmente ahora nos importa poco, porque no agrega ninguna personalización. Es algo que tiene que ver con CommonJS y sirve para poder resolver Urls relativas.
selector: este es el nombre de la etiqueta nueva que crearemos cuando se procese el componente. Es la etiqueta que usarás cuando quieras colocar el componente en cualquier lugar del HTML.
templateUrl: es el nombre del archivo .html con el contenido del componente, en otras palabras, el que tiene el código de la vista.
styleUrls: es un array con todas las hojas de estilos CSS que deben procesarse como estilo local para este componente. Como ves, podríamos tener una única declaración de estilos, o varias si lo consideramos necesario.

* Declaración de un input y output
@input: Es el mecanismo para enviar actualizaciones desde un padre hacia un hijo.

@output: Es el mecanismo para enviar actualizaciones desde un hijo hacia un padre.

import { Component, OnInit, Input } from '@angular/core';

@Component({
  selector: 'app-hijo2',
  templateUrl: './hijo2.component.html',
  styleUrls: ['./hijo2.component.css']
})
export class Hijo2Component implements OnInit {
  @Input() dataShared:boolean = false;
  constructor() { }

  ngOnInit() {
  }

}

------

import { Component, OnInit, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-hijo1',
  templateUrl: './hijo1.component.html',
  styleUrls: ['./hijo1.component.css']
})
export class Hijo1Component implements OnInit {
  @Output() emitEvent:EventEmitter<boolean> = new EventEmitter<boolean>();
  estado:boolean = false;

  constructor() { 
  }

  ngOnInit() {
    this.function1();
  }

  public function1(): boolean{
    let fResponse = !this.estado;
    this.estado = fResponse;
    this.emitEvent.emit(fResponse);
    return fResponse;
  }

}

* Observable

* Promise


* build and publish and application

* Diferencias Angular js & Angular
1.- En angular js se declaran controladores y en angular se llaman componentes.
2.- Sintaxis de las directivas estructurales diferente ejemplo ng-repeat -> *ngFor
3.- Sintaxis en el llamado de dependencias. 
var myApp = angular
   .module("miModulo", ["ngRoute"])
-----------------------
import { Injectable } from '@angular/core';
import { Http } from '@angular/http';
import { Producto } from 'app/shared/Producto.ts';
4.- El routing - $routeProvider.when() por @RouteConfig{(...})

## React
* como es un controlador
* como es un servicio
* como es una directiva
* como funciona el ruteo
* como funcionan los scopes
* tipos de scopes
* como seria una directiva
* que es un controller
* define tu modulo
* como se hace un componente
* ciclo de vida del ruteo
* tipos de datos
* hoisting
* Declaración de un input y output
* Apply y bind
* build and publish and application
* isolated scope & inherited scope
* funcion anonima
* funcion sincrona & asincrona
* variables var/let/const
* Versiones de angular

## Redux

## JSX

## Ecmascript - ES5 & ES6

* Diferencias entre ES5 & ES6

## TypeScript


## Node.js

* define tu modulo
Consider modules to be the same as JavaScript libraries.
A set of functions you want to include in your application.

var http = require('http');
http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.end('Hello World!');
}).listen(8080);

---
myfirstmodule.js
exports.myDateTime = function () {
    return Date();
};

using module:

var http = require('http');
var dt = require('./myfirstmodule');

http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    res.write("The date and time are currently: " + dt.myDateTime());
    res.end();
}).listen(8080);


## Npm

## CLI

## Git

## CSS3

## HTML5

## RestFullApis

## Frameworks
* Bootstrap
* 

## Conocimiento Gral
* Software Development Life Cycle (SDLC).
	* Stage 1: Planning and Requirement Analysis
	* Stage 2: Defining Requirements
	* Stage 3: Designing the Product Architecture
	* Stage 4: Building or Developing the Product
	* Stage 5: Testing the Product
	* Stage 6: Deployment in the Market and Maintenance
* Agile Scrum
	* ScrumMaster, the Product Owner, and the Team (which consists of Team members)
	* 15 minutes daily scrum, describe:
		* what ive done since the last scrum meeting
		* what i plan to do before the next
		* issues i have that i need help to resolve
* Simbología
  * ; Semicolon
  * > more Than
  * < less than
  * / slash
  * \ back-slash
  * # number-sign
  * " quote - quotation mark
  * '' wrap
  * !¡ exclamation mark
  * @ at
  * - dash
  * _ underscore
  * ¿? question mark
  * () parentheses
  * {} colebraisers
  * [] brackets
  * . doth or period
  * , coma
  * : colon
  * <-| break row
  * ' apostrophe
  * * asterisk